package com.example.smallwhite;import com.example.smallwhite.mybatis.dao.BabyDao;import com.example.smallwhite.mybatis.dao.BabyImageMapper;import com.example.smallwhite.mybatis.dao.BabyimageDao;import com.example.smallwhite.mybatis.entity.Baby;import com.example.smallwhite.mybatis.entity.Babyimage;import com.example.smallwhite.mybatis.service.BabyService;import com.example.smallwhite.spring.entity.Book2;import com.example.smallwhite.utils.GetDemoObject;import com.example.smallwhite.utils.JdbcUtil;import com.example.smallwhite.utils.mybatis.PageUtil;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.cache.Cache;import org.apache.ibatis.executor.BatchExecutor;import org.apache.ibatis.executor.CachingExecutor;import org.apache.ibatis.executor.ReuseExecutor;import org.apache.ibatis.executor.SimpleExecutor;import org.apache.ibatis.io.Resources;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.session.*;import org.apache.ibatis.transaction.jdbc.JdbcTransaction;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.io.Reader;import java.sql.*;import java.util.List;import java.util.UUID;/** * Mybatis测试类 * @author: yangqiang * @create: 2020-11-23 10:44 */@SpringBootTest@Slf4jpublic class MybatisTest {    private Connection connection;    private PreparedStatement preparedStatement;    //配置信息    private Configuration configuration;    //事物处理器    private JdbcTransaction jdbcTransaction;    private SqlSessionFactory factory;    @BeforeEach    public void before(){        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();        try {            factory = builder.build(Resources.getResourceAsStream("Configuration.xml"));        } catch (IOException e) {            e.printStackTrace();        }        configuration = factory.getConfiguration();        try {            Class.forName("com.mysql.jdbc.Driver");            connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/babysrj?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=UTC", "root", "root");            jdbcTransaction = new JdbcTransaction(connection);        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (SQLException e) {            e.printStackTrace();        }    }    @AfterEach    public void after(){        try {            if (connection != null) {                connection.close();            }            if (preparedStatement != null) {                preparedStatement.close();            }        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 传统JDBC下的对mysql数据库进行操作的缺点     * 1.数据库连接创建 释放 频繁操作造成系统资源浪费 从而影响系统性能     * 2.Sql语句在代码中硬编码。造成代码不易维护 实际应用中 sql变化的可能性较大。sql变动需要修改java代码 不灵活     * 3.使用preparedStatement向占有位符号传参数存在硬编码。因为sql语句的where and条件数据不一定 。可能多也可能少。修改sql还要修改代码。系统不易维护。     * 4.对结果集解析存在硬编码（查询列名）。sql变化导致解析代码变化。系统不易维护。如果能将数据库记录维护成pojo对象解析比较方便     *     * 解决问题思路     *  1.数据库频繁创建连接 释放资源 资源池     *  2.sql语句以及参数硬编码     *  3.手动解析封装返回结果集：反射 内省     *     * 自定义框架设计     *   使用端     *   提供核心配置文件     *   sqlMapConfig.xml 存放数据源信息 引入mapper.xml     *   mapper.xml: sql语句的配置文件信息     *   框架端     *   1.读取配置文件     *   读取完后以流的形式存在。我们不能讲读取到的配置信息以流的形式存放在内存中。不好操作 可以创建javaBean来存储     *   （1）Configuration：存放数据库的基本信息 Map<唯一标识，Mapper> 唯一标识：namaspace+"."+id     *   （2）MappedStatement:sql语句。statement类型。输入参数java类型。输出参数java类型     *   2.解析配置文件     *    创建SqlSessionFactoryBuilder类：     *    方法：SqlSessionFactory build();     *    第一：使用dom4j解析配置文件。将解析出来的内容封装到COnfiguration和MappedStatement中     *    第二：创建SqlSessionFactory的实现类DefaultSqlSession     *   3.创建SqlSessionFactory     *    方法：openSession():获取sqlSession接口的实现类实例对象     *   4.创建SqlSession接口及实现类：主要封装CRUD方法     *    方法：selectList(String StatementId,Object param) 查询所有     *         selectOne(String StatementId,Object param)  查询单个     *         close()释放资源     *     *   具体实现：封装JDNC完成对数据库表的查询操作     *   设计用到的设计模式     *   构建者模式，工厂模式，代理模式     *     *     * 实现     * */    @Test    public void TestJdbc() {        ResultSet resultSet = null;        try {            String sql = "select * from babyimage where id = ?";            preparedStatement = connection.prepareStatement(sql);            preparedStatement.setString(1, "0Q55mn3P9PcbAMa73V361");            resultSet = preparedStatement.executeQuery();            while (resultSet.next()) {                String id = resultSet.getString("id");                System.out.println(id);            }        } catch (SQLException e) {            e.printStackTrace();        } finally {        }    }    @Test    public void test1() {        String resource = "Configuration.xml";        Reader reader;        try {            reader = Resources.getResourceAsReader(resource);            SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();            SqlSessionFactory sqlMapper = builder.build(reader);            SqlSession sqlSession = sqlMapper.openSession();            Babyimage babyImage = sqlSession.selectOne("com.example.babysrj.mybatis.dao.BabyimageDao.queryById", "0Q55mn3P9PcbAMa73V361");            log.info(babyImage.toString());        } catch (IOException e) {            e.printStackTrace();        }    }    /**     * 简单执行器     * 每次都会创建一个新的处理器(PrepareStatement)     * */    @Test    public void SimpleExecutorTest() throws SQLException {        SimpleExecutor executor = new SimpleExecutor(configuration, jdbcTransaction);        MappedStatement ms = configuration.getMappedStatement("com.example.babysrj.mybatis.dao.BabyimageDao.queryById");        //参数 1.执行的MappedStatement 2.参数信息 3.分页信息        List<Object> objects = executor.doQuery(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER, ms.getBoundSql("0Q55mn3P9PcbAMa73V361"));        executor.doQuery(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER, ms.getBoundSql("0Q55mn3P9PcbAMa73V361"));        System.out.println(objects.get(0));    }    /**     * 可重用执行器     * 相同的sql只进行一次预处理     * */    @Test    public void ReuseExecutorTest() throws SQLException {        ReuseExecutor executor = new ReuseExecutor(configuration, jdbcTransaction);        MappedStatement ms = configuration.getMappedStatement("com.example.babysrj.mybatis.dao.BabyimageDao.queryById");        //参数 1.执行的MappedStatement 2.参数信息 3.分页信息        List<Object> objects = executor.doQuery(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER, ms.getBoundSql("0Q55mn3P9PcbAMa73V361"));        executor.doQuery(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER, ms.getBoundSql("0Q55mn3P9PcbAMa73V361"));        System.out.println(objects.get(0));    }    /**     * 批处理执行器     * 只针对新增，删除，修改操作     * */    @Test    public void BatchExecutorTest() throws SQLException {        BatchExecutor executor = new BatchExecutor(configuration, jdbcTransaction);        MappedStatement ms = configuration.getMappedStatement("com.example.babysrj.mybatis.dao.BabyimageDao.update");        //参数 1.执行的MappedStatement 2.参数信息 3.分页信息        int i = executor.doUpdate(ms, new Babyimage("0Q55mn3P9PcbAMa73V361", "q", "q", new Timestamp(System.currentTimeMillis()),"11"));        executor.doUpdate(ms, new Babyimage("0Q55mn3P9PcbAMa73V361", "q", "q", new Timestamp(System.currentTimeMillis()),"11"));        executor.doFlushStatements(false);        System.out.println(i);    }    /**     * 基础执行器     * */    @Test    public void BaseExecutorTest() throws SQLException {        SimpleExecutor executor = new SimpleExecutor(configuration, jdbcTransaction);        MappedStatement ms = configuration.getMappedStatement("com.example.babysrj.mybatis.dao.BabyimageDao.queryById");        //参数 1.执行的MappedStatement 2.参数信息 3.分页信息        executor.query(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);        //第二次调用的时候会产生缓存。 直接从一级缓存中读取结果        executor.query(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);    }    /**     *  Mybatis二级缓存处理器     *  CachingExecutor 负责二级缓存相关逻辑 executor 负责数据操作逻辑     * */    @Test    public void CachingExecutorTest() throws SQLException {        SimpleExecutor executor = new SimpleExecutor(configuration, jdbcTransaction);        CachingExecutor cachingExecutor = new CachingExecutor(executor);        MappedStatement ms = configuration.getMappedStatement("com.example.babysrj.mybatis.dao.BabyimageDao.queryById");        //参数 1.执行的MappedStatement 2.参数信息 3.分页信息        cachingExecutor.query(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);        cachingExecutor.commit(true);//先走二级缓存再走一级缓存        //第二次调用的时候会产生缓存。 直接从一级缓存中读取结果        cachingExecutor.query(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);        cachingExecutor.query(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);        cachingExecutor.query(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);        cachingExecutor.query(ms, "0Q55mn3P9PcbAMa73V361", RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);    }    /**     * 二级缓存提交后生效     * */    @Test    public void sessionTest(){        SqlSession sqlSession = factory.openSession();        //factory调用降低调用复杂性        sqlSession.selectOne("com.example.babysrj.mybatis.dao.BabyimageDao.queryById", "0Q55mn3P9PcbAMa73V361");        sqlSession.commit();        SqlSession sqlSession2 = factory.openSession();        sqlSession2.selectOne("com.example.babysrj.mybatis.dao.BabyimageDao.queryById", "0Q55mn3P9PcbAMa73V361");    }    /**     * 二级缓存作用域是Mapper 缓存结果可以在多个sqlSession中共享     * */    @Test    public void sessionTest2(){        SqlSession sqlSession = factory.openSession();        SqlSession sqlSession2 = factory.openSession();        BabyimageDao mapper = sqlSession.getMapper(BabyimageDao.class);        BabyimageDao mapper2 = sqlSession2.getMapper(BabyimageDao.class);        mapper.queryById("0Q55mn3P9PcbAMa73V361");        mapper.queryAllByLimit(1,2);//        mapper.queryById("0Q55mn3P9PcbAMa73V361");        sqlSession.commit();//        mapper2.queryById("0Q55mn3P9PcbAMa73V361");        sqlSession2.commit();        mapper2.queryById("0Q55mn3P9PcbAMa73V361");        mapper2.queryById("0Q55mn3P9PcbAMa73V361");    }    @Test    public void chcheTest(){        Cache cache = configuration.getCache("com.example.babysrj.mybatis.dao.BabyimageDao");        Babyimage object = GetDemoObject.getObject(Babyimage.class);        cache.putObject("yangqiang",object);        Object yangqiang = cache.getObject("yangqiang");    }    /**     * Mybatis关联子查询测试     *  BabyDao 对应的XML没有开启二级缓存 使用的是一级缓存 两次queryById操作之后 可以从一级缓存中读到对应的一级缓存     *  BabyimageDao 开启了二级缓存  关联子查询之后得到的list集合被 储存在二级缓存中 commit之后 后续相同的查询操作可以在二级缓存中直接获取到     * */    @Test    public void childQueryTest(){        SqlSession sqlSession = factory.openSession();        BabyDao mapper = sqlSession.getMapper(BabyDao.class);        //开启延迟加载后只有在使用到 主实体对应的子实体的时候会调用 子查询        List<Baby> baby = mapper.queryAll(new Baby());        List<Babyimage> image = baby.get(0).getImage();        Baby baby2 = mapper.queryById("1");        System.out.println(baby==baby2);        sqlSession.commit();        sqlSession.selectList("com.example.babysrj.mybatis.dao.BabyimageDao.queryByParentId", "1");        sqlSession.selectList("com.example.babysrj.mybatis.dao.BabyimageDao.queryByParentId", "1");        sqlSession.selectList("com.example.babysrj.mybatis.dao.BabyimageDao.queryByParentId", "1");        sqlSession.selectList("com.example.babysrj.mybatis.dao.BabyimageDao.queryByParentId", "1");    }    /**     * Mybatis开启延迟加载后     * */    @Test    public void lazyLoadTest(){        SqlSession sqlSession = factory.openSession();        BabyDao mapper = sqlSession.getMapper(BabyDao.class);        //开启延迟加载后 只查询 主表数据        List<Baby> baby = mapper.queryAll(new Baby());        //只有在使用到的时候会加载对应的字表信息        log.info("1");        baby.get(0).getImage();        baby.get(1).getImage();        baby.get(2).getImage();        baby.get(3).getImage();    }    /**     * Mybatis开启延迟加载后     * */    @Test    public void lazyLoadTest2(){        SqlSession sqlSession = factory.openSession();        BabyDao mapper = sqlSession.getMapper(BabyDao.class);        //开启延迟加载后 只查询 主表数据        Baby baby = mapper.queryById("1");        //只有在使用到的时候会加载对应的字表信息        System.out.println(1);        baby.getImage();    }    @Autowired    BabyService service;    /**     * 测试分页     * 1.使用RowBounds 进行分页     * 2.使用sql中添加limit进行分页     * 3.使用自定义插件进行分页（和PageHelper框架进行分页）     *     * 数据量小时RowBounds的性能还是很好地。 数据量大时 RowBounds的性能就会降低     * */    @Test    public void testPage(){        //使用自定义插件进行分页        // 这种形式是直接进行拼接 limit进行查询的物理分页        SqlSession sqlSession = factory.openSession();        BabyimageDao mapper = sqlSession.getMapper(BabyimageDao.class);        PageUtil.setPagingParam(3,5);        List<Babyimage> list = mapper.queryAll(new Babyimage());        sqlSession.commit();        PageUtil.setPagingParam(3,5);        list = mapper.queryAll(new Babyimage());        PageUtil.setPagingParam(3,5);        list = mapper.queryAll(new Babyimage());        PageUtil.setPagingParam(3,5);        list = mapper.queryAll(new Babyimage());        PageUtil.setPagingParam(3,5);        list = mapper.queryAll(new Babyimage());        log.info(String.valueOf(list.size()));    }    /**     * RowBounds分页采用的是逻辑分页     * 比如： 设置的RowBounds(10,5) 表示从第十一条开始 取 5条数据 意思是 11-15  此时Mybatis就会读取前15条数据 再舍弃前十条进行返回     * */    @Test    public void testRowBounds(){        SqlSession sqlSession = factory.openSession();        List<Object> objects = sqlSession.selectList("com.example.babysrj.mybatis.dao.BabyimageDao.queryAll", null, new RowBounds(10, 5));    }    @Test    public void testSelectList() {        SqlSession sqlSession = null;        try {            sqlSession = factory.openSession();            BabyimageDao mapper = sqlSession.getMapper(BabyimageDao.class);            PageUtil.setPagingParam(1, 2);            List<Babyimage> babyimages = mapper.queryAll(new Babyimage());            log.info(String.valueOf(babyimages.size()));            babyimages = mapper.queryAll(new Babyimage());            log.info(String.valueOf(babyimages.size()));        } catch (Exception e) {            e.printStackTrace();        } finally {            if (sqlSession != null) {                sqlSession.close();            }        }    }    /**     *  写一个用来修改参数的过滤器     *     * */    @Test    public void testParameterHandlerInterceptor(){        SqlSession sqlSession = factory.openSession();        BabyDao mapper = sqlSession.getMapper(BabyDao.class);        mapper.insert(new Baby(UUID.randomUUID().toString(),"yangqiang"));    }    @Test    public void testBatchAddRetIds(){        SqlSession sqlSession = factory.openSession();        BabyDao mapper = sqlSession.getMapper(BabyDao.class);        Object o = mapper.queryAll(new Baby());        System.out.println(o);    }    @Test    public void testLikeName(){        SqlSession sqlSession = factory.openSession();        BabyimageDao mapper = sqlSession.getMapper(BabyimageDao.class);        //字符串拼接'%${name}%'  存在sql注入        mapper.selectLikeName1("yang");        //字符串拼接 "%"#{name}"%" 没有sql注入        mapper.selectLikeName2("yang");        //字符串拼接  concat('%',#{name},'%')        mapper.selectLikeName3("yang");        //java拼接字符串        mapper.selectLikeName4("%yang%");        // 通过Mybatis动态sql标签bind进行like操作        mapper.selectLikeName5("yang");    }//    @Autowired//    BabyImageMapper mapper;    @Autowired    JdbcUtil jdbcUtil;    @Autowired    Book2 book2;    @Test    public void testSpringTransactional(){//        mapper.Insert();        jdbcUtil.query(Baby.class);        book2.setName("yangqiang");    }}