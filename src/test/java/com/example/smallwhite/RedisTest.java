package com.example.smallwhite;import com.example.smallwhite.entity.BabyImage;import com.example.smallwhite.entity.RedisKeyExpVO;import com.example.smallwhite.utils.CommonUtils;import com.example.smallwhite.utils.GetDemoObject;import com.example.smallwhite.utils.JdbcUtil;import com.google.common.base.Charsets;import com.google.common.hash.BloomFilter;import com.google.common.hash.Funnels;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.redisson.api.RLock;import org.redisson.api.RedissonClient;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.*;import java.sql.Timestamp;import java.util.*;import java.util.concurrent.TimeUnit;/** * 测试redis五种数据类型的存储 * * @author: yangqiang * @create: 2020-11-25 10:54 */@SpringBootTest@Slf4jpublic class RedisTest {    @Autowired    RedisTemplate redisTemplate;    private ValueOperations valueOperations;    private ListOperations listOperations;    private SetOperations setOperations;    private ZSetOperations zSetOperations;    private HashOperations<String, String, Object> hashOperations;    @BeforeEach    public void readyData() {        valueOperations = redisTemplate.opsForValue();        listOperations = redisTemplate.opsForList();        hashOperations = redisTemplate.opsForHash();        setOperations = redisTemplate.opsForSet();        zSetOperations = redisTemplate.opsForZSet();    }    @Test    public void test() {        for (int i = 0; i < 10002; i++) {            valueOperations.set(i + "", i + "", 10, TimeUnit.SECONDS);        }    }    /**     * 字符串（String）是 Redis 最基本的数据类型。     * String 的一个“Key”对应一个“Value”，即 Key-Value 键值对。String 是二进制安全的，可以存储任何数据（比如图片或序列化的对象）。     * 值最大能存储512MB的数据。一般用于一些复杂的计数功能的缓存。RedisTemplate 提供以下操作 String 的方法。     */    @Test    public void testString() {        //set name yangqiang        valueOperations.set("name", "yangqiang");        log.info(String.valueOf(valueOperations.get("name")));        //3秒后失效        //setex name2 3 shirujun        valueOperations.set("name2", "shirujun", 3, TimeUnit.SECONDS);        log.info(String.valueOf(valueOperations.get("name2")));        //设置键的字符串，并返回其旧值。具体用法见以下代码：        //getset name2 yangqiang2        System.out.println(valueOperations.getAndSet("name2", "yangqiang2"));        System.out.println(valueOperations.get("name2"));        //如果key已经存在，并且是一个字符串，则该命令将该值追加到字符串的末尾。如果key不存在，则它将被创建并设置为空字符串，因此 append 在这种特殊情况下类似于 set。具体用法见以下代码：        //append name2 xihuanni        valueOperations.append("name2", "xihuanni");        System.out.println(valueOperations.get("name2"));        //返回key所对应的value值的长度        //这个没找到对应的redis命令        System.out.println(valueOperations.size("name2"));    }    /**     * Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或尾部（右边）。     * 使用list数据结果，可以做简单的消息队列的功能。还可以利用 Irange 命令，做基于Reids的分页功能，性能极佳。     */    @Test    public void testList() {        String[] eat = new String[]{"mangguo", "bananan", "orange"};        String[] water = new String[]{"yibao", "nongfushanquan", "kangshifu"};        //leftPushAll方法：表示把一个数组插入列表中。第一个元素先插入第一位。第二个元素再插入第一位。以此类推 所以最后是 最后面的元素在redis的位置是第一        //lpush mangguo bananan orange        listOperations.leftPushAll("eat", Arrays.asList(eat));        //从左边插入一个元素        //将所有指定的值插入在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表（从左边插入）。        //lpush bananan        listOperations.leftPush("eat", "bananan");        //rightPushAll方法：表示向列表的最右边批量添加元素。        //rpush yibao nongfushanquan kangshifu        listOperations.rightPushAll("water", water);        //从右边插入元素        //将所有指定的值插入在键的列表的尾部。如果键不存在，则在执行推送操作之前将其创建为空列表（从右边插入）。        //rpush wahaha        listOperations.rightPush("water", "wahaha");        //lrange eat 0 -1        System.out.println((listOperations.range("eat", 0, -1)));        System.out.println((listOperations.range("water", 0, -1)));        //lindex eat 0        System.out.println((listOperations.index("eat", 0)));        //llen eat        System.out.println((listOperations.size("eat")));        // lset eat 4 chifan        listOperations.set("eat", 4, "chifan");        // lrem eat 1 chifan        // count =1        // count > 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。        // count < 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。        // count = 0 : 移除表中所有与 value 相等的值。        listOperations.remove("eat", 1, "chifan");        //弹出最左边的元素，弹出之后该值在列表中将不复存在        // lpop rat        listOperations.leftPop("eat");        //弹出最右边的元素，弹出之后该值在列表中将不复存在        //rpop eat        listOperations.rightPop("eat");    }    /**     * Redis 中的 hash（哈希）是一个 string 类型的 field 和 value 的映射表     * hash 特别适合用于存储对象。value 中存放的是结构化的对象。     * 利用这样数据结果，可以方便地操作其中的某个字段。     * 比如在“单点登录”时，可以用这种数据结构存储用户信息。     * 以 CookieId 作为 key，设置30分钟为缓存过期时间，能很好地模拟出类似 Session 的效果。     */    @Test    public void testHash() {        HashMap<String, String> map = new HashMap<>();        map.put("name", "yangqiang");        map.put("sex", "nan");        map.put("id", "1085326293");        map.put("qq", "1085326293");        //hset testhash name yangqiang        //设置 hashKey 的值。        hashOperations.put("testhash", "name", "yangqiang");        //hmset testhash name yangqiang sex man id 1085326293 qq 1085326293        //用 map 中提供的多个散列字段设置到 key 对应的散列表中。        hashOperations.putAll("testhash", map);        //hgetall testhash        //获取整个hash        hashOperations.entries("testhash");        //CommonUtils.convertToMap(babyImage) java 对象转为 HashMap 通用方法        BabyImage babyImage = new BabyImage("1085326293", "www.baidu.com", "yangqiang", new Timestamp(System.currentTimeMillis()), "11");        //CommonUtils.convertToObj(hashOperations.entries("hash_baby_image"),BabyImage.class) map转为java对象通用方法        hashOperations.putAll("hash_baby_image", CommonUtils.convertToMap(babyImage));        BabyImage babyImage1 = CommonUtils.convertToObj(hashOperations.entries("hash_baby_image"), BabyImage.class);        System.out.println(babyImage1.toString());        // hvals testhash        //获取所有值  [yangqiang, 1085326293, 1085326293, nan]        List<Object> list = hashOperations.values("testhash");        System.out.println(list);        //hkeys testhash        //获取所有testhash下的属性值        Set<String> testhash = hashOperations.keys("testhash");        log.info(String.valueOf(testhash));        //hexists testhash name        //判断hash列表中这个testhash 的name属性是否存在        System.out.println((hashOperations.hasKey("testhash", "name")));        //hlen testhash        //查询 testhash 的 属性长度        System.out.println((hashOperations.size("testhash")));        //hdel testhash name id        //删除testhash的name 和id属性        hashOperations.delete("testhash", "name", "id");    }    /**     * set 是存放不重复值的集合。     * 利用 set 可以做全局去重复的功能。     * 还可以进行交集、并集、差集等操作，也可用来实现计算共同喜好、全部的喜好、自己独有的喜好等功能。     */    @Test    public void testSet() {        String[] strings = {"1", "2", "3", "4", "5"};        //sadd testset 1 2 3 4 5        //在无序集合中添加元素，返回添加个数；如果存在重复的则不进行添加。        System.out.println(setOperations.add("testset", strings));        //smembers testset        //返回集合中所有元素        System.out.println(setOperations.members("testset"));        //srem testset 1        //删除集合中的一个元素 或者一批元素        System.out.println(setOperations.remove("testset", "1"));        System.out.println(setOperations.remove("testset", strings));        //spop testset        //移除并且返回集合中随机一个元素        System.out.println(setOperations.pop("testset"));        //smove testset testset2 1        //将testset中的元素1 移动到testset2        System.out.println(setOperations.move("testset", "1", "testset2"));        //这个不会用        //用于遍历 Set        Cursor<Object> surSor = setOperations.scan("testset", ScanOptions.NONE);        while (surSor.hasNext()) {            System.out.println(surSor.next());        }        String[] city1 = new String[]{"北京", "上海", "广州", "深圳", "昆明"};        String[] city2 = new String[]{"北京", "深圳", "昆明", "成都"};        System.out.println(setOperations.add("citySet1", city1));        System.out.println(setOperations.add("citySet2", city2));        //求交集、并集、差集（方式一）        System.out.println("求交集、并集、差集（方式一）:");        //sinter citySet1 citySet2        System.out.println("交集：" + setOperations.intersect("citySet1", "citySet2"));        //sunion citySet1 citySet2        System.out.println("并集：" + setOperations.union("citySet1", "citySet2"));        //sdiff  citySet1 citySet2        System.out.println("差集：" + setOperations.difference("citySet1", "citySet2"));        //求交集、并集、差集（方式二）        //sinterstore intersectCity citySet1 citySet2        redisTemplate.opsForSet().intersectAndStore("citySet1", "citySet2", "intersectCity");        //sunionstore unionsectCity citySet1 citySet2        redisTemplate.opsForSet().unionAndStore("citySet1", "citySet2", "unionCity");        //sdiffstore differenceCity citySet1 citySet2        redisTemplate.opsForSet().differenceAndStore("citySet1", "citySet2", "differenceCity");        System.out.println("求交集、并集、差集（方式二）:");        System.out.println("交集：" + setOperations.members("intersectCity"));        System.out.println("并集：" + setOperations.members("unionCity"));        System.out.println("差集：" + setOperations.members("differenceCity"));    }    /**     * zSet（Sorted Set 有序集合）也是 string 类型元素的集合，且不允许重复的成员。     * 每个元素都会关联一个 double 类型的分数。     * 可以通过分数将该集合中的成员从小到大进行排序。     * <p>     * zSet 的成员是唯一的，但权重参数分数（score）却可以重复。     * 集合中的元素能够按 score 进行排列。     * 它可以用来做排行榜应用、取TOP/N、延时任务、范围查找等。     */    @Test    public void testZSet() {        ZSetOperations.TypedTuple<String> objectTypedTuple1 = new DefaultTypedTuple<>("chifan", 9.6);        ZSetOperations.TypedTuple<String> objectTypedTuple2 = new DefaultTypedTuple<>("bue", 1.5);        ZSetOperations.TypedTuple<String> objectTypedTuple3 = new DefaultTypedTuple<>("woele", 7.4);        Set<ZSetOperations.TypedTuple<String>> typles = new HashSet<ZSetOperations.TypedTuple<String>>();        typles.add(objectTypedTuple1);        typles.add(objectTypedTuple2);        typles.add(objectTypedTuple3);        System.out.println(zSetOperations.add("typles", typles));        //zrange typles 0 -1        //获取集合中的元素 按照分值score 从小到大排序        System.out.println(zSetOperations.range("typles", 0, -1));        //zrangebuscore typles 0 8        //通过分数区间返回有序集合成指定区间内的成员，其中有序集成员按分数值递增(从小到大)顺序排列。        System.out.println(zSetOperations.rangeByScore("typles", 0, 8));        //zcount typles 0 8        //通过分数返回有序集合指定区间内的成员个数。        System.out.println(zSetOperations.count("typles", 0, 8));        //zcard typles        //获取有序集合的成员数。        System.out.println(zSetOperations.size(typles));        //zadd testzset 2.0 chifan        //新增一个有序集合，存在的话为false，不存在的话为true。        System.out.println(zSetOperations.add("testzset", "chifan", 2.0));        //zrem typles chifan bue woele"        //从有序集合中移除一个或者多个元素。        System.out.println(zSetOperations.remove("typles", "chifan", "bue", "woele"));        //zrank testzset chifan        //返回有序集中指定成员的排名，其中有序集成员按分数值递增(从小到大)顺序排列。        System.out.println(zSetOperations.rank("testzset", "chifan"));        //zscore typles chifan        //获取指定成员的score值        System.out.println(zSetOperations.score("typles", "chifan"));        //zremrange typles 1 5        //移除指定索引位置的成员，有序集合成员按照分数值递增(从小到大)顺序排列。        System.out.println(zSetOperations.removeRange("typles", 1, 5));        //遍历 zset        System.out.println(zSetOperations.add("zset9", typles));        Cursor<ZSetOperations.TypedTuple<Object>> cursor = redisTemplate.opsForZSet().scan("zset9", ScanOptions.NONE);        while (cursor.hasNext()) {            ZSetOperations.TypedTuple<Object> item = cursor.next();            System.out.println(item.getValue() + " 的分数值：" + item.getScore());        }    }    private static final int insertions = 1000000;    /**     * 布隆过滤器     * 离线数据加载到布隆过滤器     * 布隆过滤器是不可以删除的 因为存在hash碰撞问题     * <p>     * 布隆过滤器的误判率受到以下几个因素影响     * 1.hash函数的个数     * 2.数组的长度     * <p>     * 计数器布隆过滤器(Counting Bloom Filter)     * 标准Bloom filter对于需要精确检测结果的场景将不再适用，     * 而带计数器的Bloom filter的出现解决了这个问题。     * Counting Bloom filter实际只是在标准Bloom filter的每一个位上都额外对应得增加了一个计数器，     * 在插入元素时给对应的 k （k 为哈希函数个数）个 Counter 的值分别加 1，删除元素时给对应的 k 个 Counter 的值分别减 1。     * Counting Bloom Filter通过多占用几倍的存储空间的代价，     * 给Bloom Filter增加了删除操作。这其中最关键的问题是Counting Bloom filter需要增加多少存储量？     * 在论文中给出了相关计算，假设counter数组的长度为m（对应bloom filter的位数组），     * Ci表示counter数组中第i个counter的大小，即哈希函数映射到第i位的次数，则每个counter最少位数N为：     */    @Test    public void testBloomFilter() {        //create方法创建一个布隆过滤器        //fpp 误判率 默认为0.03 可以自己设置 设置的越精确 内部hash链表的位数组长度越长        //        long numBits = optimalNumOfBits(expectedInsertions, fpp);源码这段话的意思是计算布隆过滤器位数组长度        //        int numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits); 需要计算多少个hash函数        BloomFilter<String> filter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions, 0.01D);        //用于存放所有实际存在的key 判断key是否存在        Set<String> sets = new HashSet<>(insertions);        //用于存放所有实际存在的key 可以取出使用        List<String> lists = new ArrayList<>(insertions);        for (int i = 0; i < insertions; i++) {            String uuid = UUID.randomUUID().toString();            filter.put(uuid);            sets.add(uuid);            lists.add(uuid);        }        //正确错误的次数        int right = 0, wrong = 0;        for (int i = 0; i < 10000; i++) {            //从10000个里面取100个一定存在的数据  100 200 300 。。10000 其他9900个全部打乱重新生成UUID进行操作            String data = i % 100 == 0 ? lists.get(i) : UUID.randomUUID().toString();            //mightContain 可能存在 因为布隆过滤器的特性有误判            if (filter.mightContain(data)) {                right++;                continue;            }            wrong++;        }        System.out.println(right);        System.out.println("误判率：" + (float) (right - 100) / 100 + "%");    }    @Autowired    private RedissonClient redissonClient;    @Test    public void testRedisSon() {        RLock lock = redissonClient.getLock("testLock");        lock.lock();        lock.lock();//        lock.tryLock()        lock.unlock();        lock.unlock();    }    @Autowired    JdbcUtil jdbcUtil;    @Test    public void test1() {        for (int i = 0; i < 100; i++) {            jdbcUtil.insert(GetDemoObject.getObjectList(RedisKeyExpVO.class, 10000));        }    }    /**     * Redis实现队列模拟生产者模式     */    @Test    public void Provider() throws InterruptedException {        List<String> list = new ArrayList<>();        for (int i = 0; i < 10; i++) {            list.add(i+"");        }        Object product = listOperations.leftPushAll("product", list);    }    /**     * Redis实现队列模拟消费者模式     */    @Test    public void Consumer() throws InterruptedException {        while (true) {            Object product = listOperations.rightPop("product", 10, TimeUnit.SECONDS);            if (product != null) {                System.out.println("生产者生产了消息" + product);            }        }    }}