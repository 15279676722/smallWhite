package com.example.smallwhite;import com.example.smallwhite.java8.FunctionInterfaceImpl;import com.example.smallwhite.java8.MethodRefer;import com.example.smallwhite.java8.StreamsVO;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.util.*;import java.util.Arrays;import java.util.stream.Collectors;import java.util.stream.Stream;/** * @author: yangqiang * @create: 2021-03-05 10:00 */@Slf4j@SpringBootTestpublic class Java8Test {    /**     * java8新特性lambda函数很好用，但是有个限制，就是当Lambda函数内部使用外部的变量时，虽然不要求外部变量要用final修饰，却也不允许该外部变量被修改，这是为何呢?     * 这是因为lambda函数内使用外部变量时，并不是使用引用，而是把变量的值拷贝了一份放到自己作用域中。所以如果变量之后被修改，会造成混乱，因此外部变量虽然不需要用final修饰，但也不允许被修改。     * */    @Test    public void LambdaTest(){        String separator = ",";        Arrays.asList( "a", "b", "d" ).forEach(                ( String e ) ->System.out.print( e + separator ) );        FunctionInterfaceImpl functionInterface = new FunctionInterfaceImpl((name) -> name);        System.out.println(functionInterface.getString("yangqiang"));    }    /**     * 方法引用测试     * */    @Test    public void MethodReferTest(){        MethodRefer methodRefer = MethodRefer.create(MethodRefer::new);        final List< MethodRefer > methodRefers = Arrays.asList( methodRefer );        methodRefers.forEach(MethodRefer::collide);        methodRefers.forEach(MethodRefer::repair);        methodRefers.forEach(methodRefer::follow);    }    /**     * Optional测试     * isPresent() 判断里面是否有值     * get() 获取那一个值 通常会在前面加上isPresent() 判断是否有值 否则会报错 throw new NoSuchElementException("No value present");     * orElseGet() 获取那一个value 如果存在则返回value  如果不存在则返回lambda表达式内的函数方法返回     * orElse() 获取那一个value 如果存在则返回value  如果不存在则返回传入的other other也可以是一个函数方法     * orElse方法不管 Optional有没有值都会执行函数方法 orElseGet仅在必要的时候 即是Optional没值的时候进行调用     * */    @Test    public void OptionalTest(){        Optional<Object> empty = Optional.empty();        Object o = empty.orElseGet(() -> "替换成新的");        System.out.println(empty.orElse(""));        System.out.println(o);        System.out.println(empty.isPresent());        if(empty.isPresent()){            System.out.println(empty.get());        }        // 如果 传参是null 返回一个Optional.empty() 否则创建一个 new Optional<>(value)        Optional<Object> optional1 = Optional.ofNullable("chifan");        optional1.orElseGet(()->"替换成新的");        System.out.println(optional1.isPresent());        if(optional1.isPresent()){            System.out.println(optional1.get());        }    }    /**     * stream()    这个方法将要处理的元素看做一种流 流在管道中传输 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。     * filter()    对传入这个流的list集合进行过滤操作     * map()       过滤后的数据根据条件将流内的数据 进行转为一个map集合     * sum()       求和操作并返回结果     * average()   求平均值并返回一个OptionalDouble类型的数据 和Optional类型类似     * sorted()    排序操作 将流内的数据进行排序后返回流     * collect()   将流转换为想要的集合     * @see Collectors     * groupingBy()分组操作 在clooect()方法内使用 按照需求进行分组处理     * */    @Test    public void StreamsTest(){        List<StreamsVO> list = new ArrayList<>();        list.add(new StreamsVO(UUID.randomUUID().toString(),"yangqiang1",24,100));        list.add(new StreamsVO(UUID.randomUUID().toString(),"yangqiang2",25,99));        list.add(new StreamsVO(UUID.randomUUID().toString(),"yangqiang3",26,98));        list.add(new StreamsVO(UUID.randomUUID().toString(),"yangqiang4",27,97));        list.add(new StreamsVO(UUID.randomUUID().toString(),"yangqiang5",28,96));        int sum = list.stream().filter(item -> item.getScore() > 98).mapToInt(item -> item.getAge()).sum();        OptionalDouble average = list.stream().filter(item -> item.getScore() > 98).mapToInt(item -> item.getAge()).average();        if(average.isPresent()){            double asDouble = average.getAsDouble();        }        List<StreamsVO> collect1 = list.stream().sorted(Comparator.comparing(StreamsVO::getScore)).collect(Collectors.toList());        System.out.println(collect1.toString());        Map<Integer, List<StreamsVO>> collect2 = list.stream().collect(Collectors.groupingBy(item -> item.getScore()));    }}