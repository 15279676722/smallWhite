package com.example.smallwhite.controller;import com.example.smallwhite.entity.SecKillVO;import com.example.smallwhite.utils.JdbcUtil;import com.example.smallwhite.utils.RedisService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.redisson.api.RLock;import org.redisson.api.RedissonClient;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import java.sql.Timestamp;import java.util.Arrays;import java.util.UUID;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.locks.ReentrantLock;/** * @author: yangqiang * @create: 2020-09-09 15:27 */@Api(tags = "并发测试接口")@Slf4j@RestControllerpublic class SecKillController {    @Autowired    RedisTemplate redisTemplate;    @Value("${server.port:}")    private String port;    @Autowired    JdbcUtil jdbcUtil;    @Autowired    private RedissonClient redissonClient;    @Autowired    RedisService redisService;    /**     * 模拟高并发操作 多实例模式下     * 用nginx进行负载均衡操作     * 实行redis不超卖操作     * 使用jmeter进行高并发请求操作     */    @ApiOperation("多实例下Redis分布式锁秒杀接口 需配合Jmeter请求")    @GetMapping("/RedissionLock")    public String hello() {        String lockKey = "LockKey";        RLock lock = redissonClient.getLock(lockKey);        String message = "";        try {            lock.lock();            //是否秒杀成功            if (Integer.valueOf(String.valueOf(redisTemplate.opsForValue().get("count"))) > 0) {                Long count = redisTemplate.opsForValue().decrement("count");                SecKillVO secKillVO = new SecKillVO(UUID.randomUUID().toString(), String.valueOf(Thread.currentThread().getId()), new Timestamp(System.currentTimeMillis()), "decrement success 端口号为" + port + "，剩余" + count + "件");                jdbcUtil.insert(Arrays.asList(secKillVO));                log.info("decrement success 端口号为" + port + "，剩余" + count + "件");            }        } catch (Exception e) {            log.error(e.getMessage());        } finally {            lock.unlock();        }        // 请查看示例 https://gist.github.com/retanoj/5fd369524a18ab68a4fe7ac5e0d121e8        return jdbcUtil.query("SELECT * FROM secKill WHERE THREADID=" + String.valueOf(Thread.currentThread().getId()), SecKillVO.class).size() > 0 ? "SUCCESS" : "FAIL";    }    /**     * 代码模拟高并发操作 单例模式下操作     * doneSignal 模拟100个并发操作     */    @ApiOperation("单实例下Redis分布式锁秒杀接口")    @GetMapping("/SimulateHigh")    public Object testHigh() {        String lockKey = "LockKey";        String message = "";        RLock lock = redissonClient.getLock(lockKey);        Integer clientNum = 100;        // 模拟clientNum个客户端访问        final CountDownLatch doneSignal = new CountDownLatch(clientNum);        // 建立ExecutorService线程池，threadNum个线程可以同时访问        ExecutorService exec = Executors.newFixedThreadPool(1);        for (int i = 0; i < clientNum; i++) {            Runnable run = new Runnable() {                @Override                public void run() {                    try {                        lock.lock();                        if (Integer.valueOf(String.valueOf(redisTemplate.opsForValue().get("count"))) > 0) {                            Long count = redisTemplate.opsForValue().decrement("count");                            System.out.println("decrement success 端口号为" + port + "，剩余" + count + "件");                        } else {                            System.out.println("decrement error 端口号为" + port + "，已卖完");                        }                    } catch (Exception e) {                        log.error(e.getMessage());                    } finally {                        lock.unlock();                    }                    doneSignal.countDown();// 每调用一次countDown()方法，计数器减1                }            };            exec.execute(run);        }        try {            // 计数器大于0 时，await()方法会阻塞程序继续执行            doneSignal.await();        } catch (Exception e) {            e.printStackTrace();        }        return 1;    }    @GetMapping("/testLock")    public void testLock(){        ReentrantLock reentrantLock = new ReentrantLock();        reentrantLock.lock();        try {        }catch (Exception e){        }finally {            reentrantLock.unlock();        }    }}