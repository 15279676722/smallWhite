package com.example.smallwhite.config.rabbitmq;import org.springframework.amqp.core.*;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.HashMap;import java.util.Map;/** * direct exchange(直连型交换机)是根据消息携带的路由键（routing key）将消息投递给对应队列的，步骤如下： * 将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key） * 当一个携带着路由值为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。 * @author: yangqiang * @create: 2020-10-14 09:51 */@Configurationpublic class DirectRabbitConfig {    public static final String LIND_DL_EXCHANGE = "lind.dl.exchange";    public static final String LIND_DEAD_QUEUE = "lind.queue.dead";    private long makeCallExpire= 6000;    /**     * 直连队列 起名：TestDirectQueue     * */    @Bean    public Queue TestDirectQueue(){        // durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效        // exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable        // autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。        //   return new Queue("TestDirectQueue",true,true,false);        //一般设置一下队列的持久化就好,其余两个就是默认false        return new Queue("TestDirectQueue",true);    }    /**     * 直连队列 起名：TestDirectQueue2     * 测试绑定两个队列是否两个队列都能接收到信息     * 消息被拒绝接受后转移到配置好的死信队列中去     * */    @Bean    public Queue TestDirectQueue2(){        // durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效        // exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable        // autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。//           return new Queue("TestDirectQueue2",true,true,false);        //一般设置一下队列的持久化就好,其余两个就是默认false        return QueueBuilder.durable("TestDirectQueue2")                .withArgument("x-dead-letter-exchange", LIND_DL_EXCHANGE)//设置死信交换机                .withArgument("x-message-ttl", makeCallExpire)                .withArgument("x-dead-letter-routing-key", LIND_DEAD_QUEUE)//设置死信routingKey                .build();    }    /**     *  Direct交换机 起名：TestDirectExchange     * */    @Bean    DirectExchange TestDirectExchange(){        //  return new DirectExchange("TestDirectExchange",true,true);        return new DirectExchange("TestDirectExchange",true,false);    }    /**     * 将交换机和队列绑定     */    @Bean    Binding bindingDirect(){        return BindingBuilder.bind(TestDirectQueue()).to(TestDirectExchange()).with("TestDirectRouting");    }    /**     * 将交换机和队列2绑定     */    @Bean    Binding bindingDirect2(){        return BindingBuilder.bind(TestDirectQueue2()).to(TestDirectExchange()).with("TestDirectRouting2");    }    @Bean    DirectExchange lonelyDirectExchange() {        return new DirectExchange("lonelyDirectExchange");    }    /**     * 创建死信交换机.     */    @Bean    public TopicExchange lindExchangeDl() {        return (TopicExchange) ExchangeBuilder.topicExchange(LIND_DL_EXCHANGE).durable(true)                .build();    }    /**     * 创建死信队列.     */    @Bean    public Queue lindDelayQueue() {        return QueueBuilder.durable(LIND_DEAD_QUEUE).build();    }    /**     * 绑定死信队列.     */    @Bean    public Binding bindDeadBuilders() {        return BindingBuilder.bind(lindDelayQueue())                .to(lindExchangeDl())                .with(LIND_DEAD_QUEUE);    }}