package com.example.smallwhite.thread;import lombok.AllArgsConstructor;import lombok.Data;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.ScheduledExecutorService;/** * Executors.newCachedThreadPool： *   必要时创建新线程，空闲线程会保留60秒。 *   0个核心线程 Inyeger.MAX个非核心线程池 *   可以无限创建线程 所以处理速度快 也可以线程复用 * Executors.newFixedThreadPool：创建固定容量的线程池。 *   固定容量的线程池 参数 为核心线程数  非核心线程数为0 * Executors.newSingleThreadPool：创建只有一个线程的线程池。 *   只存在一个线程的线程池 1个核心线程 0个非核心线程 如果一个线程的请求时间长需要在队列等待 * Executors.newScheduledThreadPool：用于预定指定的线程池。 * * @author: yangqiang * @create: 2021-03-19 10:42 */public class ThreadPoolTest {    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService1 = Executors.newCachedThreadPool();        ExecutorService executorService2 = Executors.newFixedThreadPool(10);        ExecutorService executorService3 = Executors.newSingleThreadExecutor();        ExecutorService executorService4 = Executors.newScheduledThreadPool(10);        long l1 = System.currentTimeMillis();        long l2 = System.currentTimeMillis();        for (int i = 0; i < 100; i++) {            executorService3.execute(new MyRunnable(i));        }        executorService3.shutdown();    }    @Data    @AllArgsConstructor    static    class MyRunnable implements Runnable {        private Integer count;        @Override        public  void run() {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName()+"-"+count);        }    }}