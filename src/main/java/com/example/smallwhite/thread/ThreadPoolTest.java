package com.example.smallwhite.thread;import lombok.AllArgsConstructor;import lombok.Data;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.locks.ReentrantLock;/** * Executors.newCachedThreadPool： * 必要时创建新线程，空闲线程会保留60秒。 * 0个核心线程 Integer.MAX个非核心线程池 * 可以无限创建线程 所以处理速度快 也可以线程复用 * Executors.newFixedThreadPool：创建固定容量的线程池。 * 固定容量的线程池 参数 为核心线程数  非核心线程数为0 * Executors.newSingleThreadPool：创建只有一个线程的线程池。 * 只存在一个线程的线程池 1个核心线程 0个非核心线程 如果一个线程的请求时间长需要在队列等待 * Executors.newScheduledThreadPool：用于预定指定的线程池。 * * @author: yangqiang * @create: 2021-03-19 10:42 */public class ThreadPoolTest {    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService1 = Executors.newCachedThreadPool(new NamedThreadFactory("newCachedThreadPool"));        ExecutorService executorService2 = Executors.newFixedThreadPool(10,new NamedThreadFactory("newFixedThreadPool"));        ExecutorService executorService3 = Executors.newSingleThreadExecutor(new NamedThreadFactory("newSingleThreadExecutor"));        ExecutorService executorService4 = Executors.newScheduledThreadPool(10,new NamedThreadFactory("newScheduledThreadPool"));        for (int i = 0; i < 100; i++) {            executorService1.execute(new MyRunnable(i));            executorService2.execute(new MyRunnable(i));            executorService3.execute(new MyRunnable(i));            executorService4.execute(new MyRunnable(i));        }        executorService1.shutdown();        executorService2.shutdown();        executorService3.shutdown();        executorService4.shutdown();    }    @Data    @AllArgsConstructor    static    class MyRunnable implements Runnable {        private Integer count;        @Override        public void run() {            System.out.println(Thread.currentThread().getName() + "-" + count);        }    }    static class NamedThreadFactory implements ThreadFactory {        private AtomicInteger threadNumber = new AtomicInteger(0);        private String prefix;        public NamedThreadFactory(String prefix) {            this.prefix = prefix;        }        @Override        public Thread newThread(Runnable r) {            return new Thread(r, prefix + threadNumber.getAndIncrement());        }    }}