package com.example.smallwhite.thread;import io.swagger.models.auth.In;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 读写锁 * 读锁是一种共享锁 其他读之间可以进行共享锁操作 * 写锁是一种独占锁 与其他读写之间不可以进行共享 * 当读锁被线程获取时 此时写锁也是获取不到的 * 当写锁被线程获取时 此时读锁也是获取不到的 * 读-读操作可以多次获取锁 进行get操作 * 读-写操作不能同时获取锁 产生脏读 * 写-写操作不能同时获取锁 * * @author: yangqiang * @create: 2021-03-10 14:49 */public class WriteReadLockTest {    private volatile Map<String, Object> map = new HashMap<>();    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    public void put(String key, Object value) {        lock.writeLock().lock();        Thread thread = Thread.currentThread();        System.out.println(thread.getName() + "获取锁！ 进行写入操作");        map.put(key, value);        System.out.println(thread.getName() + "写入" + key + "成功");        System.out.println("---------------");        System.out.println("写进程去获取数据操作");        get(key);        System.out.println(thread.getName() + "释放锁！writeLock");        lock.writeLock().unlock();    }    public void get(String key) {        lock.readLock().lock();        Thread thread = Thread.currentThread();        System.out.println(thread.getName() + "获取锁！ 进行读取操作");        while (map.get(key) == null){            try {                System.out.println("读取中key = "+key+"value =" + map.get(key));                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }        System.out.println("读取成功key = "+key+"value =" + map.get(key));        System.out.println(thread.getName() + "释放锁！readLock");        lock.readLock().unlock();    }    public static void main(String[] args) {        WriteReadLockTest writeReadLockTest = new WriteReadLockTest();        for (int i = 1; i < 21; i++) {            int finalI = i;            new Thread(new Runnable() {                @Override                public void run() {                    if ((finalI & 1) == 1) {                        writeReadLockTest.put(finalI + "", finalI);                    } else {                        writeReadLockTest.get(finalI-1 + "");                    }                }            }, (finalI & 1) == 1?"写线程":"读线程").start();        }//        for (int i = 0; i < 10; i++) {//            int finalI = i;//            new Thread(new Runnable() {//                @Override//                public void run() {//                    writeReadLockTest.get(finalI + "");//                }//            }, "读线程").start();//        }    }}