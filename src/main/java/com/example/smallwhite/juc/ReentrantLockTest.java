package com.example.smallwhite.juc;import java.util.concurrent.locks.ReentrantLock;/** * ReentrantLock 有公平锁和非公平锁两种 默认 NonfairSync 非公平锁 * <p> * NonfairSync情况 * 1.尝试将 state 修改(CAS)为1 有两种情况 *    1.成功的话更新当前独占线程为当前线程 *    2.判断state是否为0 尝试重新去更新state获取锁(公平锁会优先让队列的头部节点获得锁) 不为0的话 则判断当前独占锁的线程是否为当前线程。因为ReentrantLock是可重入的 所以可以多次加锁 将state +1 *    3.尝试将当前线程加入到等待队列中去 进行排队 *          1.如果当前线程排在第一位再次去尝试获取锁～ *          2.直接加入队列中 暂时中断线程 等待唤醒 *    4.独占锁线程每调用一次unlock 会使得state-1  如果有多次加锁操作 需要 进行同样的解锁操作。释放锁后会去唤醒队列头结点的线程 执行请求 *  fairSync情况 *  公平锁的加锁流程 *    1.判断state是否为0 为0的话再判断当前等待队列中 如果没有头节点 或者头节点为当前线程 则尝试去加锁 *    2.其他步骤和非公平锁类似 * * @author: yangqiang * @create: 2021-03-08 15:52 */public class ReentrantLockTest {    private static ReentrantLock reentrantLock = new ReentrantLock();    public static void main(String[] args) {        for (int i = 0; i < 10; i++) {            new ReentrantLockThread("thread-" + i).start();        }    }    static class ReentrantLockThread extends Thread {        public ReentrantLockThread(String name) {            super(name);        }        @Override        public void run() {            reentrantLock.lock();            reentrantLock.lock();            try {            } catch (Exception e) {            } finally {                reentrantLock.unlock();            }        }    }}