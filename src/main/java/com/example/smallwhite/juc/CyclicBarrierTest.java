package com.example.smallwhite.juc;import java.util.concurrent.*;/** * CyclicBarrier 让所有线程进入准备状态全部 准备好之后一起执行 * 和CountDownWatch的区别是 *   CountDownWatch锁住的是主线程 作用是让主线程等待 其他线程都执行完之后 再执行 * @author: yangqiang * @create: 2021-03-30 16:56 */public class CyclicBarrierTest {    public static void main(String[] args) {        CyclicBarrier cyclicBarrier = new CyclicBarrier(2);        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10,10,0, TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());        for (int i = 0; i < 2; i++) {            threadPoolExecutor.execute(()->{                System.out.println("线程开始执行");                try {                    //当前线程进入等待  等待其他线程一起执行下面的操作                    cyclicBarrier.await();                    System.out.println("线程结束执行");                } catch (InterruptedException e) {                    e.printStackTrace();                } catch (BrokenBarrierException e) {                    e.printStackTrace();                }            });        }        System.out.println("11");        for (int i = 0; i < 2; i++) {            threadPoolExecutor.execute(()->{                System.out.println("线程开始执行");                try {                    cyclicBarrier.await();                    System.out.println("线程结束执行");                } catch (InterruptedException e) {                    e.printStackTrace();                } catch (BrokenBarrierException e) {                    e.printStackTrace();                }            });        }    }}