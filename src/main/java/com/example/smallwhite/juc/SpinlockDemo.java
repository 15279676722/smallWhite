package com.example.smallwhite.juc;import java.util.concurrent.atomic.AtomicReference;/** * 自旋锁 * 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去获取锁，这样的好处是减少线程上下文切换的消耗，缺点就是增加CPU的消耗 * @author: yangqiang * @create: 2021-03-10 14:30 */public class SpinlockDemo {    private AtomicReference<Thread> atomicReference = new AtomicReference<Thread>();    public void lock() {        Thread thread = Thread.currentThread();        do {            System.out.println(thread.getName()+"正在获取锁");            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }        } while (!atomicReference.compareAndSet(null, thread));    }    public void unlock() {        atomicReference.set(null);    }    public static void main(String[] args) throws InterruptedException {        SpinlockDemo spinlockDemo = new SpinlockDemo();        new Thread(() -> {            System.out.println("t1--->获取锁");            spinlockDemo.lock();            System.out.println("t1--->获取锁成功");            try {                System.out.println("t1--->");                Thread.sleep(5 * 1000);            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                System.out.println("t1--->解锁");                spinlockDemo.unlock();                System.out.println("t1--->解锁成功");            }        }, "t1").start();        Thread.sleep(1000);        new Thread(() -> {            System.out.println("t2--->获取锁");            spinlockDemo.lock();            System.out.println("t2--->获取锁成功");            try {                System.out.println("t2--->");                Thread.sleep(1 * 1000);            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                System.out.println("t2--->解锁");                spinlockDemo.unlock();                System.out.println("t2--->解锁成功");            }        }, "t2").start();    }}