package com.example.smallwhite.cas;/** * volatile    只能保证可见性，不能保证原子性 * i=i+1 * 底层有三个步骤 * 1. 拿到内存中的i * 2. i+1 * 3. 把 i +1赋值给i * 线程1 执行12 在执行3的时候 * 线程2 执行12 同时执行3 * 这样使得出现了并发操作 * @author: yangqiang * @create: 2021-03-26 11:13 */import java.util.concurrent.CountDownLatch;import java.util.concurrent.atomic.AtomicInteger;public class VolatileTest {    public static AtomicInteger count = new AtomicInteger();//原子操作    public static CountDownLatch latch = new CountDownLatch(1000);//线程协作处理    public static volatile int countNum = 0;//volatile    只能保证可见性，不能保证原子性    public static int synNum = 0;//同步处理计算    public static void inc() {        try {            Thread.sleep(1);        } catch (InterruptedException e) {        }        countNum++;        int c = count.addAndGet(1);        add();        System.out.println(Thread.currentThread().getName() + "------>" + c);    }    public static synchronized void add() {        synNum++;    }    public static void main(String[] args) {        //同时启动1000个线程，去进行i++计算，看看实际结果        for (int i = 0; i < 1000; i++) {            new Thread(new Runnable() {                @Override                public void run() {                    VolatileTest.inc();                    latch.countDown();                }            }, "thread" + i).start();        }        try {            latch.await();        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName());        System.out.println("运行结果:Counter.count=" + count.get() + ",,," + countNum + ",,," + synNum);    }}