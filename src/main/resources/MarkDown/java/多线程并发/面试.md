### 1.并行与并发的区别

并行是同一时刻在计算机中同时执行，并发是一段时间内多个任务在计算机中交替执行

### 2.线程和进程的区别

进程就是一个程序运行中资源分配的基本单位。一个程序中至少有一个进程，而一个进程中又至少有一个线程，一一般是多个线程。多个线程同时操作共享内存资源 效率更好。一般考虑多线程开发

### 3.什么是守护线程

Java线程分为用户线程和守护线程。

守护线程是程序运行的时候在后台提供一种通用服务的线程。所有用户线程停止，进程会停掉所有守护线程，退出程序。

Java中把线程设置为守护线程的方法：在 start 线程之前调用线程的 setDaemon(true) 方法。

注意：

setDaemon(true) 必须在 start() 之前设置，否则会抛出IllegalThreadStateException异常，该线程仍默认为用户线程，继续执行
守护线程创建的线程也是守护线程
守护线程不应该访问、写入持久化资源，如文件、数据库，因为它会在任何时间被停止，导致资源未释放、数据写入中断等问题

#### 守护线程的应用

**应用场景**

（1）来为其它线程提供服务支持的情况；（2） 或者在任何情况下，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；反之，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程。通常都是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。


> **GC垃圾回收线程**：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。



### 4.线程创建方式

#### 1.继承Thread

```java
package com.example.smallwhite.thread.mythread;

public class ThreadExtend extends Thread{

    public ThreadExtend(String name) {
        super(name);
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
        System.out.println("my-thread-test");
    }
}
```

#### 2.实现Runnable

```java
package com.example.smallwhite.thread.mythread;

public class RunnableImp implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
        System.out.println("my-runnable-test");
    }
}
```

#### 3.实现Callable

```java
package com.example.smallwhite.thread.mythread;

import java.util.concurrent.Callable;

public class CallableImp implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println(Thread.currentThread().getName());
        return "my-callable-test";
    }
}
```

测试：

```java
package com.example.smallwhite.thread;

import com.example.smallwhite.thread.mythread.CallableImp;
import com.example.smallwhite.thread.mythread.RunnableImp;
import com.example.smallwhite.thread.mythread.ThreadExtend;

import java.util.concurrent.FutureTask;


public class ThreadTest {
    public static void main(String[] args) throws Exception {
        ThreadExtend threadExtend = new ThreadExtend("my-thread");
        threadExtend.start();

        Thread thread = new Thread(new RunnableImp(), "my-runnable");
        thread.start();

        CallableImp callableImp = new CallableImp();
        FutureTask futureTask = new FutureTask(callableImp);
        Thread callableThread = new Thread(futureTask, "my-callable");
        callableThread.start();
        System.out.println(futureTask.get());
    }
}
```

#### 4.线程池



```java
package com.example.smallwhite.thread;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Executors.newCachedThreadPool：
 * 必要时创建新线程，空闲线程会保留60秒。
 * 0个核心线程 Integer.MAX个非核心线程池
 * 可以无限创建线程 所以处理速度快 也可以线程复用
 * Executors.newFixedThreadPool：创建固定容量的线程池。
 * 固定容量的线程池 参数 为核心线程数  非核心线程数为0
 * Executors.newSingleThreadPool：创建只有一个线程的线程池。
 * 只存在一个线程的线程池 1个核心线程 0个非核心线程 如果一个线程的请求时间长需要在队列等待
 * Executors.newScheduledThreadPool：用于预定指定的线程池。
 *
 */
public class ThreadPoolTest {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService1 = Executors.newCachedThreadPool(new NamedThreadFactory("newCachedThreadPool"));

        ExecutorService executorService2 = Executors.newFixedThreadPool(10,new NamedThreadFactory("newFixedThreadPool"));
        ExecutorService executorService3 = Executors.newSingleThreadExecutor(new NamedThreadFactory("newSingleThreadExecutor"));
        ExecutorService executorService4 = Executors.newScheduledThreadPool(10,new NamedThreadFactory("newScheduledThreadPool"));
        long l1 = System.currentTimeMillis();
        long l2 = System.currentTimeMillis();
        for (int i = 0; i < 100; i++) {
            executorService1.execute(new MyRunnable(i));
            executorService2.execute(new MyRunnable(i));
            executorService3.execute(new MyRunnable(i));
            executorService4.execute(new MyRunnable(i));
        }
        executorService1.shutdown();
        executorService2.shutdown();
        executorService3.shutdown();
        executorService4.shutdown();

    }

    @Data
    @AllArgsConstructor
    static
    class MyRunnable implements Runnable {
        private Integer count;

        @Override
        public void run() {

            System.out.println(Thread.currentThread().getName() + "-" + count);
        }
    }

    static class NamedThreadFactory implements ThreadFactory {

        private AtomicInteger threadNumber = new AtomicInteger(0);
        private String prefix;

        public NamedThreadFactory(String prefix) {
            this.prefix = prefix;
        }

        @Override
        public Thread newThread(Runnable r) {
            return new Thread(r, prefix + threadNumber.getAndIncrement());
        }
    }
}
```

### 5.runnable和callable的区别

Runnable接口中run方法的返回值是void在其中可以定义线程的工作任务，但无返回值

callable接口中call方法有返回值，是一个泛型，一般会和Future、FutureTask配合使用，能异步得到线程的执行结果



### 6.sleep和wait和yield有什么区别

#### 1.sleep

> Thread.sleep()是Thread类的一个静态方法，使当前线程休眠，进入阻塞状态（暂停执行），如果线程在睡眠状态被中断，将会抛出IterruptedException中断异常。

```java
package com.example.smallwhite.thread;

public class SleepTest {
    public static void main(String[] args) throws InterruptedException {

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName()+i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"my-thread").start();
        
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()+i);
            Thread.sleep(1000);
        }

    }
}
```



```java
main0
my-thread0
main1
my-thread1
main2
my-thread2
my-thread3
main3
main4
my-thread4
main5
my-thread5
my-thread6
main6
my-thread7
main7
main8
my-thread8
my-thread9
main9
```

- sleep()方法是Thread类的静态方法，如果调用线程对象.sleep()方法转入(blocked)阻塞状态
- 线程睡眠到期自动苏醒，并返回到可运行状态（就绪），不是运行状态。
- sleep属于TIMED_WAITING 到期就唤醒
- sleep在持有锁时执行不会释放锁资源
- sleep可以在不持有锁的情况下执行

#### 2.wait

```java
package com.example.smallwhite.thread;

public class WaitTest {
    public static void main(String[] args) {
        Object a = new Object();


        new Thread(() -> {
            String threadName = Thread.currentThread().getName();
            synchronized (a){
                System.out.println(threadName+"synchronized a");
                try {
                    System.out.println(threadName+"a wait ");
                    a.wait(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(threadName+"a end ");

            }

        },"thread-1").start();

        new Thread(() -> {
            String threadName = Thread.currentThread().getName();
            synchronized (a){
                System.out.println(threadName+"synchronized a");
                try {
                    System.out.println(threadName+"a wait ");
                    a.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(threadName+"a end ");

            }

        },"thread-2").start();


        new Thread(()-> {
                String threadName = Thread.currentThread().getName();
                synchronized (a){
                    System.out.println(threadName+"synchronized a");
                    System.out.println(threadName+"a notify ");
                    a.notifyAll();
                    System.out.println(threadName+"a end ");
                }

            },"thread-3").start();
    }
}
```

```java
thread-1synchronized a
thread-1a wait 
thread-2synchronized a
thread-2a wait 
thread-3synchronized a
thread-3a notify 
thread-3a end 
thread-2a end 
thread-1a end 
```

- wait属于Object中的方法 每个对象中都可以调用
- wait属于WAITING 需要手动唤醒
- wait会让出锁资源
- wait必须在持有锁的情况下调用不然会抛异常(底层是要往ObjectMonitor的WaitSet中添加元素)

#### 3.yield

> 使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。

```java
package com.example.smallwhite.thread;

public class YieldTest {
    public static void main(String[] args) {
        MyThread t1 = new MyThread("t1");
        MyThread t2 = new MyThread("t2");
        t1.start();
        t2.start();
    }

    static class MyThread extends Thread {


        public MyThread(String name) {
            super(name);
        }


        @Override
        public void run() {
            for (int i = 1; i < 20; i++) {
                System.out.println(currentThread().getName() + " : " + i);
                if (i % 2 == 0) {
                    System.out.println(currentThread().getName() + " : " + i + "-释放出cpu资源");
                    yield();
                    System.out.println(currentThread().getName() + " : " + i + "-拿到cpu资源");
                }
            }


        }
    }
}

```

- yield()方法是Thread类的静态方法，使当前线程从执行状态（运行状态）变为可执行态（就绪状态），由cpu重新调度 在下一个线程执行时候，此线程有可能被执行，也有可能没有被执行



### 7.run和start有什么区别

start用来启动线程，通过线程调用run方法中所定义的逻辑代码，start只能被调用一次，

run封装了要被线程执行的代码，可以被调用多次



### 8.如何停止一个正在运行的线程

1. 使用退出标志正常退出
2. 使用stop强行终止 (stop直接终止所有线程,有些未执行完的线程也会被中止，不推荐使用)
3. 使用interrupt方法中断线程(interrupt 可以针对 sleep()和wait() 方法进行收尾操作 而stop就比较暴力)

### 9.有三个线程T1、T2、T3，如何保证他们顺序执行

使用线程类的join方法在一个线程中启动另一个线程

