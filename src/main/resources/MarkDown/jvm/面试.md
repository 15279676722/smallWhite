### 什么是双亲委派机制

> java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的calss文件时，java虚拟机采用的是双亲委派模式，即把请求交由给父类处理，他是一种任务委派模式 

#### 工作原理

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给最上层的父类加载器去执行 最终到达启动类加载器进行执行
2. 如果父类加载器可以完成类加载的任务。就成功返回，倘若夫类加载器无法完成此加载任务，子加载器才会尝试自己去加载。这就是双亲委派模式

#### 双亲委派机制优势

- 避免类的重复加载
- 保护程序安全，避免java核心API被篡改，比如自定义 java.lang.String 此时会加载核心类String 执行main方法的时候报错没有main方法。或者自定义一个java.lang.myTest 会报错 Prohibited package name: java 不可以使用这个包名
- 实现一些SPI接口的时候由 引导类加载器加载 核心jar包。具体实现类为第三方jar包由系统类加载加载

#### 沙箱安全机制

> 对于自定义的java.lang.String 类，加载的时候会使用引导类加载器进行加载， 运行main方法的时候会报错没有main方法。因为加载的是rt.jat包中的String类。这样可以保证对java核心源代码的保护。这个就叫沙箱安全机制



### 使用PC寄存器存储字节码指令地址有什么用呢。为什么使用PC寄存器记录当前线程的执行地址呢

- CPU需要不停的在多个线程之间切换，切换完成后需要知道接着应该从哪里开始继续执行。
- JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 

### PC寄存器为什么会被设定为线程私有



![image-20230218164704120.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aad14ed26104fd4afd8fc31e16d0a0b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)


### 4.虚拟机栈会出现什么异常

### 1.StackOverFlowError

```java
package com.example.smallwhite.jvm.chapter05;

public class StackOverFlowTest {
    private static int count = 0;
    public static void main(String[] args) {
        System.out.println(++count);
        main(args);
    }
}
```

> 递归调用出现死循环的时候并且采用的是固定的虚拟机栈内存   会报StackOverFlowError
>
> 如果采用的是动态扩展的虚拟机内存的话 则会报错 OutOfMemoryError

![image-20230219164539007](../image/image-20230219164539007.png)
=======





### 常用的jvm命令

```js
设置栈空间大小
-Xss1m
-Xss1024k
-Xss1048576

设置堆空间大小
-Xms10m 设置堆区的起始内存
-Xmx10m 设置堆区的最大内存
-Xmn100m 设置
打印GC过程中的细节
-XX:+PrintGCDetails

-XX:NewRatio=2 表示新生代占1 老年代占2  新生代占整个堆的 1/3
-XX:SurvivorRatio=8 表示新生代Eden:surv0:surv1 =8:1:1 但是堆有自适应机制可能不是这个比例
-XX:-UseAdaptiveSizePolicy   -关闭自适应内存分配策略 +打开自适应内存分配策略

-XX:MaxTenuringThreshold=<N> 进行设置 从幸存者区->老年代转换的阈值
```

